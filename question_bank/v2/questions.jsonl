{"schema_version": "2.0", "id": "BSON-Q001", "title": "BSON type for precise monetary values", "topic": "MongoDB Overview", "subtopic": "BSON data types", "difficulty": "easy", "type": "single", "tags": ["bson", "decimal128", "money", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Which BSON type is best for storing precise monetary values?\n", "context": "You are designing a schema that stores currency amounts where rounding errors must be avoided (for example, prices, balances, or financial data).\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["Floating-point types can introduce rounding errors.", "MongoDB provides a high-precision decimal type specifically for financial data."]}, "choices": [{"key": "A", "text": "Double"}, {"key": "B", "text": "Decimal128"}, {"key": "C", "text": "String"}, {"key": "D", "text": "Int32"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "Use Decimal128 for exact precision when storing monetary values.\n", "correct_why": ["Decimal128 stores decimal floating-point values with high precision.", "It avoids rounding errors common with binary floating-point types like Double.", "MongoDB explicitly recommends Decimal128 for financial calculations."], "wrong_why": {"A": "Double is a binary floating-point type and can introduce rounding errors.", "C": "String cannot be used for numeric calculations without conversion.", "D": "Int32 cannot represent fractional monetary values."}, "trap": "Using Double for money, which can silently introduce precision errors.\n", "mini_demo": "db.payments.insertOne({\n  amount: NumberDecimal(\"199.99\"),\n  currency: \"USD\"\n})\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "BSON-Q002", "title": "Internal representation of unique document identifiers", "topic": "MongoDB Overview", "subtopic": "ObjectId", "difficulty": "easy", "type": "single", "tags": ["bson", "objectid", "_id", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "How does MongoDB represent unique document identifiers internally?\n", "context": "By default, MongoDB automatically generates a unique value for the `_id` field when one is not explicitly provided.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["MongoDB automatically generates `_id` values unless explicitly provided.", "The default `_id` type encodes time and uniqueness information."]}, "choices": [{"key": "A", "text": "UUID"}, {"key": "B", "text": "ObjectId"}, {"key": "C", "text": "Random String"}, {"key": "D", "text": "Auto-incremented Integer"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "MongoDB uses ObjectId as the default unique identifier for documents.\n", "correct_why": ["ObjectId is a 12-byte BSON type designed for uniqueness.", "It includes a timestamp, machine identifier, process id, and counter.", "MongoDB generates ObjectId values automatically for `_id`."], "wrong_why": {"A": "UUIDs can be used, but they are not MongoDB’s default identifier type.", "C": "MongoDB does not generate random strings for `_id` values.", "D": "MongoDB does not use auto-incrementing integers by default."}, "trap": "Assuming MongoDB uses UUIDs by default because they are common in other databases.\n", "mini_demo": "db.users.insertOne({ name: \"Alice\" })\n// _id: ObjectId(\"656f0c8e8f9c4a1b2d3e4f5a\")\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "BSON-Q003", "title": "Type for storing nested objects", "topic": "MongoDB Overview", "subtopic": "BSON data types – embedded documents", "difficulty": "easy", "type": "single", "tags": ["bson", "embedded-document", "schema-design", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "What type should be used to store a nested object within a document?\n", "context": "You are designing a MongoDB document that contains structured data grouped logically under a single field (for example, an address or profile).\n", "artifacts": {"sample_docs": [{"name": "Alice", "address": {"city": "Hyderabad", "pincode": "500001"}}], "snippets": [], "notes": ["MongoDB documents can contain other documents.", "This pattern is called embedding and is core to MongoDB’s data model."]}, "choices": [{"key": "A", "text": "Array"}, {"key": "B", "text": "Embedded Document"}, {"key": "C", "text": "String"}, {"key": "D", "text": "Binary"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "Use an embedded document to store structured, nested data.\n", "correct_why": ["Embedded documents allow related fields to be grouped together.", "They preserve structure and enable dot-notation queries.", "This is the recommended approach for nested objects in MongoDB."], "wrong_why": {"A": "Arrays are used for lists of values, not structured key–value objects.", "C": "Strings cannot represent structured nested data.", "D": "Binary is used for raw binary data, not documents."}, "trap": "Confusing arrays of values with embedded documents that store structured objects.\n", "mini_demo": "db.users.insertOne({\n  name: \"Bob\",\n  profile: {\n    age: 30,\n    occupation: \"Engineer\"\n  }\n})\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q001", "title": "Projection: explicitly exclude _id", "topic": "CRUD", "subtopic": "find() projection", "difficulty": "easy", "type": "single", "tags": ["projection", "find", "_id", "exam-trap"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Which query returns only the `name` field while excluding `_id`?\n", "context": "You want to return a minimal response payload when reading user profiles.\n", "artifacts": {"sample_docs": [{"_id": 1, "name": "Alice", "age": 30}, {"_id": 2, "name": "Bob", "age": 25}], "snippets": [], "notes": ["`_id` is included by default in all find() results.", "`_id` is the only field that can be excluded while including others."]}, "choices": [{"key": "A", "text": "db.users.find({}, { name: 1 })"}, {"key": "B", "text": "db.users.find({}, { name: 1, _id: 0 })"}, {"key": "C", "text": "db.users.find({}, { name: 1, _id: -1 })"}, {"key": "D", "text": "db.users.find({}, { name: true })"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "`_id` is included by default and must be explicitly excluded using `_id: 0`.\n", "correct_why": ["`name: 1` includes only the name field.", "`_id: 0` explicitly removes `_id` from the result.", "This follows MongoDB’s projection inclusion rules."], "wrong_why": {"A": "`_id` is included by default, so it will still appear in the result.", "C": "`_id: -1` is not a valid projection value.", "D": "`true` behaves like `1`, so `_id` is still included unless explicitly excluded."}, "trap": "Assuming that projecting a single field automatically removes `_id`.\n", "mini_demo": "db.users.find({}, { name: 1 }).limit(1)\n// Result: { _id: ObjectId(...), name: \"Alice\" }\n\ndb.users.find({}, { name: 1, _id: 0 }).limit(1)\n// Result: { name: \"Alice\" }\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q002", "title": "Insert a single document", "topic": "CRUD", "subtopic": "insertOne()", "difficulty": "easy", "type": "single", "tags": ["insert", "mongosh", "basics"], "exam_relevance": {"pool": "learning", "confidence": "high"}, "prompt": "What methods are available in MongoDB for inserting a single document?\n", "context": "You are working in the MongoDB Shell (mongosh) and need to add exactly one document to a collection.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["insertOne() is the standard and recommended method to insert a single document.", "insertMany() is used only when inserting multiple documents.", "Older insert() exists but is deprecated and not tested in the Associate exam."]}, "choices": [{"key": "A", "text": ".insertOne()"}, {"key": "B", "text": ".inserting()"}, {"key": "C", "text": ".InsertDocument()"}, {"key": "D", "text": ".insertMany()"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "One document → insertOne(), many documents → insertMany().\n", "correct_why": ["insertOne() is a valid MongoDB Shell method for inserting exactly one document.", "It returns an acknowledgment with the inserted _id.", "This method is explicitly tested in CRUD basics for the Associate exam."], "wrong_why": {"B": "inserting() is not a MongoDB Shell method.", "C": "InsertDocument() is not a valid MongoDB API method.", "D": "insertMany() is used only for inserting multiple documents, not a single one."}, "trap": "Confusing insertMany() with insertOne() because both insert documents.\n", "mini_demo": "db.users.insertOne({\n  name: \"Prashanth\",\n  role: \"developer\"\n})\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q003", "title": "Insert multiple documents", "topic": "CRUD", "subtopic": "insertMany()", "difficulty": "easy", "type": "single", "tags": ["insert", "mongosh", "bulk-insert"], "exam_relevance": {"pool": "learning", "confidence": "high"}, "prompt": "What methods are available in MongoDB for inserting multiple documents?\n", "context": "You are working in the MongoDB Shell (mongosh) and need to insert more than one document into a collection in a single operation.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["insertMany() is the standard method for inserting multiple documents at once.", "insertOne() is only for a single document.", "Bulk inserts are more efficient than repeated single inserts."]}, "choices": [{"key": "A", "text": ".InsertDocument()"}, {"key": "B", "text": ".inserting()"}, {"key": "C", "text": ".insertOne()"}, {"key": "D", "text": ".insertMany()"}], "answer": {"keys": ["D"]}, "rationale": {"rule": "Multiple documents → insertMany().\n", "correct_why": ["insertMany() is a valid MongoDB Shell method for inserting multiple documents.", "It accepts an array of documents as input.", "This is the correct and recommended approach for bulk inserts."], "wrong_why": {"A": "InsertDocument() is not a valid MongoDB Shell method.", "B": "inserting() does not exist in the MongoDB API.", "C": "insertOne() can insert only a single document, not multiple."}, "trap": "Assuming insertOne() can automatically handle multiple documents if passed an array.\n", "mini_demo": "db.users.insertMany([\n  { name: \"Alice\", role: \"admin\" },\n  { name: \"Bob\", role: \"user\" }\n])\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q004", "title": "Find documents in a collection", "topic": "CRUD", "subtopic": "find()", "difficulty": "easy", "type": "single", "tags": ["find", "query", "mongosh"], "exam_relevance": {"pool": "learning", "confidence": "high"}, "prompt": "What methods are available in MongoDB for finding documents?\n", "context": "You are working in the MongoDB Shell (mongosh) and need to retrieve documents from a collection.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["find() is the primary method used to retrieve documents.", "findOne() also exists, but find() returns a cursor and can match multiple documents.", "Methods like query() or search() are not MongoDB Shell methods."]}, "choices": [{"key": "A", "text": ".find()"}, {"key": "B", "text": ".query()"}, {"key": "C", "text": ".finding()"}, {"key": "D", "text": ".search()"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "To retrieve documents → use find().\n", "correct_why": ["find() is a valid MongoDB Shell method for retrieving documents.", "It can return zero, one, or many documents depending on the query.", "This is the foundational read operation in MongoDB CRUD."], "wrong_why": {"B": "query() is not a MongoDB Shell method.", "C": "finding() does not exist in the MongoDB API.", "D": "search() is related to Atlas Search, not basic document retrieval."}, "trap": "Confusing Atlas Search terminology with basic CRUD read operations.\n", "mini_demo": "db.users.find({ role: \"admin\" })\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q005", "title": "Match documents using $in operator", "topic": "CRUD", "subtopic": "Query operators – $in", "difficulty": "easy", "type": "single", "tags": ["find", "in-operator", "filters", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "You are searching for data in a small area in downtown Chicago with the following zip codes: \"60601\", \"60602\", \"60603\", \"60604\", \"60605\", \"60606\". Which of the following query documents should you use to ensure that only the documents with the specified zip codes are returned?\n", "context": "Each document contains a field named `zip` that stores a single ZIP code as a string.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["$in matches documents where the field value equals ANY value in the provided array.", "$nin is the logical opposite of $in.", "Equality without $in can match only ONE value."]}, "choices": [{"key": "A", "text": "{ zip: { $nin: [\"60601\", \"60602\", \"60603\", \"60604\", \"60605\", \"60606\"] } }"}, {"key": "B", "text": "{ zip: { $in: [\"60601\", \"60602\", \"60603\", \"60604\", \"60605\", \"60606\"] } }"}, {"key": "C", "text": "{ zip: { $eq: \"60601\", \"60602\", \"60603\", \"60604\", \"60605\", \"60606\" } }"}, {"key": "D", "text": "{ zip: \"60601\", \"60602\", \"60603\", \"60604\", \"60605\", \"60606\" }"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "Multiple allowed values for one field → use $in.\n", "correct_why": ["$in returns documents where the field matches any value in the array.", "This ensures only the specified ZIP codes are returned.", "This is the standard pattern tested for multi-value filters."], "wrong_why": {"A": "$nin excludes the listed values instead of including them.", "C": "$eq matches only one value and cannot accept multiple values.", "D": "Implicit equality can match only a single value, not multiple."}, "trap": "Confusing $in with $nin or assuming equality can accept multiple values.\n", "mini_demo": "db.addresses.find({\n  zip: { $in: [\"60601\", \"60602\", \"60603\", \"60604\", \"60605\", \"60606\"] }\n})\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q006", "title": "Filter using comparison operators", "topic": "CRUD", "subtopic": "Comparison operators – $lte", "difficulty": "easy", "type": "single", "tags": ["find", "comparison-operators", "lte", "nested-fields", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Your company is conducting research on customer experience and needs to identify unsatisfied customers. You need to find all customers with a satisfaction rating of 1 or 2. Which of the following query documents would return all such customers?\n", "context": "The satisfaction rating is stored as a numeric field inside a nested document called `customer`.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["Use dot notation to query nested fields (\"parent.child\").", "$lte means less than or equal to.", "To include both 1 and 2, the comparison must allow equality."]}, "choices": [{"key": "A", "text": "{ \"customer.satisfaction\": { $gt: 1 } }"}, {"key": "B", "text": "{ customer.satisfaction: { $lte: 2 } }"}, {"key": "C", "text": "{ \"customer.satisfaction\": { $lt: 2 } }"}, {"key": "D", "text": "{ \"customer.satisfaction\": { $lte: 2 } }"}], "answer": {"keys": ["D"]}, "rationale": {"rule": "To match a range that includes the boundary value, use $lte or $gte.\n", "correct_why": ["$lte: 2 matches all values less than or equal to 2.", "This correctly returns customers with satisfaction ratings of 1 or 2.", "Dot notation is used correctly to access the nested field."], "wrong_why": {"A": "$gt: 1 returns values greater than 1, which includes satisfied customers.", "B": "Dot notation is missing quotes, making the query syntactically incorrect.", "C": "$lt: 2 excludes customers with a rating of exactly 2."}, "trap": "Forgetting equality when the question explicitly includes boundary values (\\\"1 or 2\\\").\n", "mini_demo": "db.customers.find({\n  \"customer.satisfaction\": { $lte: 2 }\n})\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q007", "title": "Find customers aged 65 or older", "topic": "CRUD", "subtopic": "Comparison operators – $gte / $gt", "difficulty": "easy", "type": "multi", "tags": ["find", "comparison-operators", "gte", "gt", "nested-fields", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Your company wants to offer a special discount for customers who are 65 or older. Your task is to find the records for these customers. Which of the following queries would return documents for all customers aged 65 or older?\n", "context": "Customer age is stored as a numeric field inside a nested document named `customer`.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["Use dot notation (\"customer.age\") to query nested fields.", "$gte includes the boundary value.", "$gt can also be used if you shift the boundary logically."]}, "choices": [{"key": "A", "text": "{ customer.age: { $gte: 65 } }"}, {"key": "B", "text": "{ \"customer.age\": { $gt: 64 } }"}, {"key": "C", "text": "{ \"customer.age\": { $gte: 65 } }"}, {"key": "D", "text": "{ \"customer.age\": { $lte: 65 } }"}], "answer": {"keys": ["B", "C"]}, "rationale": {"rule": "“65 or older” means age ≥ 65.\n", "correct_why": ["Option B works because $gt: 64 is logically equivalent to age ≥ 65.", "Option C directly expresses the requirement using $gte: 65.", "Both correctly include customers who are exactly 65."], "wrong_why": {"A": "Missing quotes around the dotted field path makes the query invalid syntax.", "D": "$lte: 65 returns customers aged 65 or younger, not older."}, "trap": "Mixing up $lte and $gte, or forgetting that $gt: 64 is equivalent to $gte: 65.\n", "mini_demo": "# Two correct ways\ndb.customers.find({ \"customer.age\": { $gte: 65 } })\ndb.customers.find({ \"customer.age\": { $gt: 64 } })\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q008", "title": "Match subdocuments inside arrays", "topic": "CRUD", "subtopic": "Array queries – $elemMatch", "difficulty": "easy", "type": "single", "tags": ["arrays", "elemMatch", "subdocuments", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Which of the following operators can be used to find a subdocument that matches specific criteria in an array?\n", "context": "You are querying an array field that contains embedded documents and need to ensure multiple conditions apply to the same array element.\n", "artifacts": {"sample_docs": [{"_id": 1, "scores": [{"type": "math", "score": 85}, {"type": "english", "score": 92}]}], "snippets": [], "notes": ["$elemMatch ensures that multiple conditions apply to the same array element.", "Without $elemMatch, conditions may match different elements in the array."]}, "choices": [{"key": "A", "text": "&element"}, {"key": "B", "text": "$elemMatch"}, {"key": "C", "text": "$subMatch"}, {"key": "D", "text": "$docMatch"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "Use $elemMatch when multiple conditions must match the same array element.\n", "correct_why": ["$elemMatch is the official MongoDB operator for matching subdocuments in arrays.", "It guarantees all criteria are evaluated against a single array element.", "This operator is heavily tested in array-query exam questions."], "wrong_why": {"A": "&element is not a valid MongoDB operator.", "C": "$subMatch does not exist in MongoDB.", "D": "$docMatch is not a valid MongoDB query operator."}, "trap": "Forgetting $elemMatch and unintentionally matching conditions across different elements of the same array.\n", "mini_demo": "db.students.find({\n  scores: {\n    $elemMatch: { type: \"math\", score: { $gt: 80 } }\n  }\n})\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q009", "title": "Equality match on scalar vs array field", "topic": "CRUD", "subtopic": "find() equality on arrays", "difficulty": "easy", "type": "single", "tags": ["find", "equality", "arrays", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "What will the following query return? db.books.find({ genre: \"Historical\" })\n", "context": "The `genre` field may be stored either as a single string value or as an array of strings in different documents.\n", "artifacts": {"sample_docs": [{"_id": 1, "title": "Book A", "genre": "Historical"}, {"_id": 2, "title": "Book B", "genre": ["Fiction", "Historical"]}, {"_id": 3, "title": "Book C", "genre": ["Fantasy"]}], "snippets": [], "notes": ["An equality match on an array field returns documents where the array contains the value.", "MongoDB does NOT search across all fields unless explicitly told to do so."]}, "choices": [{"key": "A", "text": "All documents where the `genre` field is equal to either the scalar value \"Historical\" or an array that contains \"Historical\".\n"}, {"key": "B", "text": "All documents that contain the string \"Historical\" across any field.\n"}, {"key": "C", "text": "All documents where the `genre` field does not contain the value \"Historical\".\n"}, {"key": "D", "text": "No documents, because equality matching does not work on arrays.\n"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "Equality matching works on both scalar fields and array elements.\n", "correct_why": ["If the field is a scalar, MongoDB checks for direct equality.", "If the field is an array, MongoDB checks whether the array contains the value.", "This behavior is implicit and does not require $in or $elemMatch."], "wrong_why": {"B": "A basic find() does not perform global text search across all fields.", "C": "The query checks for equality, not exclusion.", "D": "Equality matching *does* work on arrays by checking for membership."}, "trap": "Assuming equality only works for scalar fields and not arrays.\n", "mini_demo": "// Matches both documents below\ndb.books.find({ genre: \"Historical\" })\n// { genre: \"Historical\" }\n// { genre: [\"Fiction\", \"Historical\"] }\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q010", "title": "Implicit AND in query documents", "topic": "CRUD", "subtopic": "Logical operators – implicit AND", "difficulty": "easy", "type": "single", "tags": ["find", "and", "logical-operators", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "You want to know which mobile food trucks in your neighborhood, Astoria, are the best spots to eat. Using the `inspections` collection, you are making a map of all mobile food trucks nearby that have passed inspection. What should you include in your query document to ensure that you find all the mobile food vendors in Astoria that passed inspection?\n", "context": "Each document includes fields for `sector`, `address.city`, and `result`.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["MongoDB applies an implicit AND when multiple fields are specified in a query document.", "You only need $and when combining multiple conditions on the same field or using complex expressions."]}, "choices": [{"key": "A", "text": "{ \"sector\": \"Mobile Food Vendor - 881\" }, { \"address.city\": \"ASTORIA\" }, { \"result\": \"Pass\" }"}, {"key": "B", "text": "$and: { \"Mobile Food Vendor - 881\", \"ASTORIA\", \"Pass\" }"}, {"key": "C", "text": "{ \"sector\": \"Mobile Food Vendor - 881\", \"address.city\": \"ASTORIA\", \"result\": \"Pass\" }"}, {"key": "D", "text": "&and: { \"Mobile Food Vendor - 881\", \"ASTORIA\", \"Pass\" }"}], "answer": {"keys": ["C"]}, "rationale": {"rule": "Multiple field conditions in a query document are combined using an implicit AND.\n", "correct_why": ["Specifying multiple fields in a single query document applies AND logic automatically.", "This query correctly filters by sector, city, and inspection result.", "This is the simplest and most idiomatic MongoDB query for this use case."], "wrong_why": {"A": "Multiple query documents separated by commas is not valid MongoDB syntax.", "B": "$and requires an array of expressions, not raw values.", "D": "&and is not a valid MongoDB operator."}, "trap": "Assuming $and is required for every multi-condition query, when MongoDB already applies AND logic implicitly.\n", "mini_demo": "db.inspections.find({\n  sector: \"Mobile Food Vendor - 881\",\n  \"address.city\": \"ASTORIA\",\n  result: \"Pass\"\n})\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q012", "title": "Understanding replaceOne() behavior", "topic": "CRUD", "subtopic": "replaceOne()", "difficulty": "easy", "type": "multi", "tags": ["update", "replaceOne", "mongosh", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Which of the following statements regarding the `replaceOne()` method for the MongoDB Shell (`mongosh`) are true?\n", "context": "You are updating documents using replacement semantics instead of update operators.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["`replaceOne()` completely replaces the matched document except for `_id`.", "It does NOT use update operators like `$set`.", "Only one document can be replaced per operation."]}, "choices": [{"key": "A", "text": "This method is used to replace a single document that matches the filter document.\n"}, {"key": "B", "text": "This method accepts a filter document, a replacement document, and an optional options document.\n"}, {"key": "C", "text": "This method can replace multiple documents in a collection.\n"}, {"key": "D", "text": "This method returns a document containing an acknowledgement of the operation, a matched count, modified count, and an upserted ID (if applicable).\n"}], "answer": {"keys": ["A", "B", "D"]}, "rationale": {"rule": "replaceOne() replaces exactly one document and returns an operation result object.\n", "correct_why": ["replaceOne() targets only a single matching document.", "Its signature is replaceOne(filter, replacement, options).", "The result includes acknowledged, matchedCount, modifiedCount, and upsertedId."], "wrong_why": {"C": "replaceOne() cannot replace multiple documents; updateMany() or bulk operations are required."}, "trap": "Confusing replaceOne() with updateMany() or assuming it behaves like update operators.\n", "mini_demo": "db.users.replaceOne(\n  { username: \"alice\" },\n  { username: \"alice\", age: 31 },\n  { upsert: false }\n)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q013", "title": "Using _id as a filter for replaceOne()", "topic": "CRUD", "subtopic": "replaceOne() filter", "difficulty": "easy", "type": "single", "tags": ["replaceOne", "_id", "filters", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "You want to replace the following document from the `birds` collection with a new document that contains additional information such as recent sightings, scientific name, and wingspan. What field should you use in the filter document to ensure that this specific document is replaced?\n", "context": "Each document in the `birds` collection has a unique `_id` field generated by MongoDB.\n", "artifacts": {"sample_docs": [{"_id": "ObjectId('6286809e2f3fa87b7d86dccd')", "common_name": "Morning Dove", "habitat": ["urban areas", "farms", "grassland"], "diet": ["seeds"]}], "snippets": [], "notes": ["`_id` uniquely identifies a document in a collection.", "Using non-unique fields can unintentionally match multiple documents.", "replaceOne() replaces the first matching document."]}, "choices": [{"key": "A", "text": "{ _id: ObjectId(\"6286809e2f3fa87b7d86dccd\") }"}, {"key": "B", "text": "{ diet: [\"seeds\"] }"}, {"key": "C", "text": "{ habitat: [\"urban areas\"] }"}, {"key": "D", "text": "{ scientific_name: \"Zenaida macroura\" }"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "To target one exact document, always filter using its `_id`.\n", "correct_why": ["`_id` is guaranteed to be unique within a collection.", "Filtering by `_id` ensures only the intended document is replaced.", "This is the safest and most precise filter for replaceOne()."], "wrong_why": {"B": "Multiple bird documents may share the same diet.", "C": "Many birds can have the same habitat value.", "D": "The scientific_name field does not yet exist in the document."}, "trap": "Assuming any matching field is safe for replacement, which can lead to replacing the wrong document.\n", "mini_demo": "db.birds.replaceOne(\n  { _id: ObjectId(\"6286809e2f3fa87b7d86dccd\") },\n  {\n    common_name: \"Morning Dove\",\n    scientific_name: \"Zenaida macroura\",\n    wingspan_cm: 45\n  }\n)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q014", "title": "Behavior of insertOne()", "topic": "CRUD", "subtopic": "insertOne()", "difficulty": "easy", "type": "single", "tags": ["insertOne", "insert", "crud", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Which of the following is true about the `insertOne()` command?\n", "context": "You are inserting data into a MongoDB collection using the MongoDB Shell or a MongoDB driver.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["`insertOne()` is used only for inserting exactly one document.", "It does not modify or update existing documents."]}, "choices": [{"key": "A", "text": "It inserts multiple documents at once"}, {"key": "B", "text": "It inserts a single document into a collection"}, {"key": "C", "text": "It updates existing documents"}, {"key": "D", "text": "It replaces an existing document"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "insertOne() always inserts exactly one new document.\n", "correct_why": ["insertOne() adds a single document to a collection.", "If `_id` is not provided, MongoDB generates one automatically.", "This is the most basic insert operation in MongoDB."], "wrong_why": {"A": "insertMany() is used for inserting multiple documents.", "C": "Updates are performed using updateOne(), updateMany(), or replaceOne().", "D": "Replacement uses replaceOne(), not insertOne()."}, "trap": "Confusing insertOne() with update or replace operations.\n", "mini_demo": "db.users.insertOne({ name: \"Charlie\", age: 28 })\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q015", "title": "Valid insertOne() document structure", "topic": "CRUD", "subtopic": "insertOne() document validity", "difficulty": "easy", "type": "single", "tags": ["insertOne", "schema-flexibility", "exam-trap"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "What is wrong with the following insert command?\ndb.movies.insertOne({ genres: \"Drama\", year: 2015 })\n", "context": "You are inserting a new movie document into the `movies` collection and want to verify whether the document structure is valid.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["MongoDB does not require a fixed schema by default.", "MongoDB automatically generates `_id` if it is not provided.", "Field data types are application-defined unless schema validation is enabled."]}, "choices": [{"key": "A", "text": "genres should be an array"}, {"key": "B", "text": "year should be a string"}, {"key": "C", "text": "Document must include _id"}, {"key": "D", "text": "Nothing is wrong with this command"}], "answer": {"keys": ["D"]}, "rationale": {"rule": "MongoDB allows flexible schemas and auto-generates `_id` values.\n", "correct_why": ["MongoDB allows fields to store scalar values or arrays unless restricted by validation.", "The `year` field can be stored as a number.", "`_id` is automatically generated if not explicitly provided.", "Therefore, the insert command is valid."], "wrong_why": {"A": "Arrays are optional; a single string value is allowed.", "B": "Numeric values are valid for year fields.", "C": "MongoDB auto-generates `_id` when missing."}, "trap": "Assuming MongoDB enforces relational-style schemas or requires `_id` to be explicitly set.\n", "mini_demo": "db.movies.insertOne({ genres: \"Drama\", year: 2015 })\n// Insert succeeds, MongoDB adds _id automatically\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q016", "title": "Updating multiple documents", "topic": "CRUD", "subtopic": "updateMany()", "difficulty": "easy", "type": "single", "tags": ["update", "updateMany", "crud", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Which command updates multiple documents matching a filter?\n", "context": "You are modifying documents in a MongoDB collection and want all documents that match a given filter to be updated in a single operation.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["MongoDB provides separate methods for updating one vs many documents.", "Insert and update operations are distinct in MongoDB."]}, "choices": [{"key": "A", "text": "updateOne"}, {"key": "B", "text": "updateMany"}, {"key": "C", "text": "insertMany"}, {"key": "D", "text": "replaceOne"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "updateMany() modifies all documents that match the filter.\n", "correct_why": ["updateMany() applies the update to every matching document.", "It is designed for bulk updates using a single filter.", "This behavior is explicitly tested in CRUD exam questions."], "wrong_why": {"A": "updateOne() updates only the first matching document.", "C": "insertMany() inserts documents; it does not update existing ones.", "D": "replaceOne() replaces only a single document."}, "trap": "Confusing insertMany() with updateMany() because both operate on multiple documents.\n", "mini_demo": "db.users.updateMany(\n  { status: \"inactive\" },\n  { $set: { archived: true } }\n)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q017", "title": "updateMany() without update operators", "topic": "CRUD", "subtopic": "updateMany() replacement behavior", "difficulty": "easy", "type": "single", "tags": ["updateMany", "replacement", "update-operators", "exam-trap"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "What happens if you run `updateMany()` without using an update operator (such as `$set`)?\n", "context": "You are updating documents in a collection and accidentally provide a plain document instead of using update operators.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["MongoDB distinguishes between update operators and replacement documents.", "This behavior is identical for updateOne() and updateMany()."]}, "choices": [{"key": "A", "text": "Partial update is performed"}, {"key": "B", "text": "Matched documents are replaced with the provided document"}, {"key": "C", "text": "Error is thrown"}, {"key": "D", "text": "Only the first matched document is updated"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "An update without operators is treated as a full document replacement.\n", "correct_why": ["When no update operators are used, MongoDB treats the update document as a replacement.", "All matched documents are replaced except for the `_id` field.", "This applies to both updateOne() and updateMany()."], "wrong_why": {"A": "Partial updates require operators like `$set`.", "C": "MongoDB allows replacement-style updates; it does not throw an error.", "D": "updateMany() affects all matching documents, not just one."}, "trap": "Forgetting update operators and accidentally replacing entire documents.\n", "mini_demo": "// Replaces all matched documents (except _id)\ndb.users.updateMany(\n  { status: \"active\" },\n  { status: \"inactive\" }\n)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q018", "title": "Effect of updateMany() with $inc", "topic": "CRUD", "subtopic": "updateMany() with update operators", "difficulty": "easy", "type": "single", "tags": ["updateMany", "$inc", "update-operators", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Given the following command, what is its effect?\ndb.products.updateMany(\n  { category: \"Electronics\" },\n  { $inc: { stock: 10 } }\n)\n", "context": "The `products` collection contains multiple documents, each with a `category` field and a numeric `stock` field.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["$inc increments (adds to) an existing numeric field.", "updateMany() applies the update to all documents matching the filter."]}, "choices": [{"key": "A", "text": "All Electronics products have their stock increased by 10"}, {"key": "B", "text": "Only one Electronics product is updated"}, {"key": "C", "text": "All products have stock reset to 10"}, {"key": "D", "text": "An error occurs because $inc cannot be used with updateMany()"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "updateMany() + $inc increments a numeric field for all matching documents.\n", "correct_why": ["The filter matches all documents where category is 'Electronics'.", "$inc adds 10 to the existing value of the stock field.", "updateMany() applies this update to every matched document."], "wrong_why": {"B": "updateOne() updates a single document, not updateMany().", "C": "$inc increments the value; it does not reset it.", "D": "$inc is a valid update operator and works with updateMany()."}, "trap": "Confusing $inc with replacement updates or assuming updateMany() affects only one document.\n", "mini_demo": "// Before: stock = 5\n// After:  stock = 15\ndb.products.updateMany(\n  { category: \"Electronics\" },\n  { $inc: { stock: 10 } }\n)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q019", "title": "Effect of replaceOne() on omitted fields", "topic": "CRUD", "subtopic": "replaceOne() behavior", "difficulty": "easy", "type": "single", "tags": ["replaceOne", "replacement", "update-vs-replace", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "What happens to fields that are omitted in a `replaceOne()` operation?\n", "context": "You are replacing an existing document with a new one using replacement semantics instead of update operators.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["replaceOne() performs a full document replacement.", "Only the `_id` field is preserved automatically."]}, "choices": [{"key": "A", "text": "They remain unchanged"}, {"key": "B", "text": "They are deleted from the document"}, {"key": "C", "text": "The operation fails"}, {"key": "D", "text": "They are set to null"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "replaceOne() removes all fields not present in the replacement document.\n", "correct_why": ["replaceOne() replaces the entire document except for `_id`.", "Any field not included in the replacement document is removed.", "This is the key difference between replaceOne() and update operators."], "wrong_why": {"A": "Fields are preserved only when using update operators like `$set`.", "C": "replaceOne() is a valid operation and does not fail due to omitted fields.", "D": "Fields are removed, not set to null."}, "trap": "Thinking replaceOne() behaves like updateOne() with `$set`.\n", "mini_demo": "// Original document\n{ _id: 1, name: \"Phone\", price: 500, stock: 20 }\n\n// replaceOne()\ndb.products.replaceOne(\n  { _id: 1 },\n  { name: \"Phone\", price: 550 }\n)\n\n// Result\n{ _id: 1, name: \"Phone\", price: 550 }\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q020", "title": "Updating specific fields without removing others", "topic": "CRUD", "subtopic": "updateOne() with update operators", "difficulty": "easy", "type": "single", "tags": ["updateOne", "$set", "update-vs-replace", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Which update command would you use to modify only certain fields in a document without removing the other existing fields?\n", "context": "You want to safely update part of a document while preserving all other fields.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["Update operators modify specific fields.", "Replacement updates overwrite the entire document."]}, "choices": [{"key": "A", "text": "replaceOne() with partial document"}, {"key": "B", "text": "updateOne() with $set operator"}, {"key": "C", "text": "updateOne() with full document replacement"}, {"key": "D", "text": "updateMany() without update operators"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "Use update operators like $set to change specific fields safely.\n", "correct_why": ["$set updates only the specified fields.", "All other fields in the document remain unchanged.", "This is the recommended and safest way to perform partial updates."], "wrong_why": {"A": "replaceOne() replaces the entire document, removing omitted fields.", "C": "Full document replacement overwrites all existing fields.", "D": "Updates without operators trigger full document replacement."}, "trap": "Thinking that providing a partial document automatically performs a partial update.\n", "mini_demo": "db.users.updateOne(\n  { _id: 1 },\n  { $set: { email: \"new@mail.com\" } }\n)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q021", "title": "updateOne() without update operators", "topic": "CRUD", "subtopic": "updateOne() replacement behavior", "difficulty": "easy", "type": "single", "tags": ["updateOne", "replacement", "exam-trap", "update-operators"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Given a document `{ a: 1, b: 2, c: 3 }`, what is the result after running the following command?\ndb.collection.updateOne({ a: 1 }, { b: 5 })\n", "context": "The update command is executed without using any update operators such as `$set`.\n", "artifacts": {"sample_docs": [{"a": 1, "b": 2, "c": 3}], "snippets": [], "notes": ["An update document without operators is treated as a replacement.", "`_id` is preserved automatically during replacement."]}, "choices": [{"key": "A", "text": "Document now has fields { b: 5 }"}, {"key": "B", "text": "Document now has { a: 1, b: 5, c: 3 }"}, {"key": "C", "text": "Operation error"}, {"key": "D", "text": "Only field b is updated, others become null"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "updateOne() without update operators performs a full document replacement.\n", "correct_why": ["The update document `{ b: 5 }` is treated as a replacement document.", "All existing fields except `_id` are removed.", "The resulting document contains only `{ b: 5 }` (plus `_id`)."], "wrong_why": {"B": "Keeping other fields requires update operators like `$set`.", "C": "MongoDB allows replacement-style updates without error.", "D": "Omitted fields are removed, not set to null."}, "trap": "Assuming updateOne() performs partial updates even without `$set`.\n", "mini_demo": "// Original\n{ _id: 1, a: 1, b: 2, c: 3 }\n\n// updateOne without operators\ndb.collection.updateOne({ a: 1 }, { b: 5 })\n\n// Result\n{ _id: 1, b: 5 }\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q022", "title": "Partial updates using update operators", "topic": "CRUD", "subtopic": "updateOne() with $set", "difficulty": "easy", "type": "single", "tags": ["updateOne", "$set", "partial-update", "exam-core"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Which MongoDB command updates only specified fields without affecting other existing fields in a document?\n", "context": "You want to modify one or more fields in a document while keeping all remaining fields unchanged.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["Update operators modify fields in-place.", "Replacement updates overwrite the entire document."]}, "choices": [{"key": "A", "text": "updateOne with full document replacement"}, {"key": "B", "text": "updateOne using $set"}, {"key": "C", "text": "insertOne"}, {"key": "D", "text": "replaceOne with partial document"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "Use update operators like $set for safe partial updates.\n", "correct_why": ["$set updates only the specified fields.", "All other fields remain untouched.", "This is the recommended approach for modifying part of a document."], "wrong_why": {"A": "Full document replacement removes fields that are not included.", "C": "insertOne() inserts new documents; it does not update existing ones.", "D": "replaceOne() always replaces the entire document."}, "trap": "Thinking that providing a partial document automatically performs a partial update.\n", "mini_demo": "db.users.updateOne(\n  { _id: 1 },\n  { $set: { email: \"updated@mail.com\" } }\n)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q023", "title": "Effect of updateOne() with $set", "topic": "CRUD", "subtopic": "updateOne() with $set", "difficulty": "easy", "type": "single", "tags": ["updateOne", "$set", "partial-update", "exam-core"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "After executing the following command, what will be true?\ndb.movies.updateOne(\n  { title: \"Inception\" },\n  { $set: { year: 2012, rating: 9.0 } }\n)\n", "context": "The `movies` collection already contains a document with the title \"Inception\" and other existing fields.\n", "artifacts": {"sample_docs": [{"title": "Inception", "director": "Christopher Nolan", "year": 2010}], "snippets": [], "notes": ["$set updates only the specified fields.", "Fields not mentioned in $set remain unchanged."]}, "choices": [{"key": "A", "text": "Only year and rating fields are updated or added"}, {"key": "B", "text": "All other fields in the document are deleted"}, {"key": "C", "text": "The operation fails"}, {"key": "D", "text": "The entire document is replaced with only year and rating"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "$set performs a partial update and does not remove existing fields.\n", "correct_why": ["$set updates existing fields or adds them if they do not exist.", "All other fields in the document remain unchanged.", "This is the safe way to modify specific fields."], "wrong_why": {"B": "Field deletion happens only with replacement updates or $unset.", "C": "This is a valid update operation and does not fail.", "D": "Full replacement occurs only when no update operators are used."}, "trap": "Confusing $set-based updates with full document replacement.\n", "mini_demo": "// Before\n{ title: \"Inception\", director: \"Christopher Nolan\", year: 2010 }\n\n// After\n{\n  title: \"Inception\",\n  director: \"Christopher Nolan\",\n  year: 2012,\n  rating: 9.0\n}\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q024", "title": "Using $set on a non-existing field", "topic": "CRUD", "subtopic": "update operators – $set", "difficulty": "easy", "type": "single", "tags": ["update", "$set", "field-creation", "exam-core"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "What happens if you try to update a field using `$set` that did not previously exist in the document?\n", "context": "You are updating documents and want to understand how MongoDB handles new fields during update operations.\n", "artifacts": {"sample_docs": [{"name": "Laptop", "price": 50000}], "snippets": [], "notes": ["$set is used for both updating existing fields and creating new fields.", "MongoDB updates are schema-flexible unless validation is enabled."]}, "choices": [{"key": "A", "text": "MongoDB throws an error"}, {"key": "B", "text": "MongoDB creates the new field with the given value"}, {"key": "C", "text": "MongoDB ignores the new field"}, {"key": "D", "text": "The entire document is replaced"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "$set creates the field if it does not already exist.\n", "correct_why": ["$set adds new fields when they are not present.", "This behavior supports MongoDB’s flexible schema model.", "No error is thrown for new fields by default."], "wrong_why": {"A": "MongoDB allows adding new fields unless schema validation blocks it.", "C": "MongoDB never silently ignores a valid $set update.", "D": "Replacement occurs only when no update operators are used."}, "trap": "Assuming $set only works on fields that already exist.\n", "mini_demo": "db.products.updateOne(\n  { name: \"Laptop\" },\n  { $set: { warranty_years: 2 } }\n)\n\n// Result:\n// { name: \"Laptop\", price: 50000, warranty_years: 2 }\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q025", "title": "Adding an element to an array field", "topic": "CRUD", "subtopic": "Array updates with $push", "difficulty": "easy", "type": "single", "tags": ["arrays", "$push", "update-operators", "exam-core"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "You want to add an element to the `items` array field in the `sales` collection. What should you include in the update document?\n", "context": "Each document in the `sales` collection contains an `items` array that stores purchased products as embedded documents.\n", "artifacts": {"sample_docs": [{"_id": 1, "items": [{"name": "phone", "price": 500}]}], "snippets": [], "notes": ["Use array update operators to modify array fields.", "$push appends a new element to an existing array."]}, "choices": [{"key": "A", "text": "{ $set: { items: [{ \"name\": \"tablet\", \"price\": 200 }] } }"}, {"key": "B", "text": "{ $update: { items: [{ \"name\": \"tablet\", \"price\": 200 }] } }"}, {"key": "C", "text": "{ $push: { items: { \"name\": \"tablet\", \"price\": 200 } } }"}, {"key": "D", "text": "{ $upsert: { items: [{ \"name\": \"tablet\", \"price\": 200 }] } }"}], "answer": {"keys": ["C"]}, "rationale": {"rule": "Use $push to add a new element to an array field.\n", "correct_why": ["$push appends a single element to an existing array.", "It preserves existing array elements.", "This is the correct operator for adding items to arrays."], "wrong_why": {"A": "$set replaces the entire array, removing existing elements.", "B": "$update is not a valid MongoDB update operator.", "D": "$upsert is an option, not an update operator for arrays."}, "trap": "Using $set instead of $push, which accidentally overwrites the array.\n", "mini_demo": "db.sales.updateOne(\n  { _id: 1 },\n  { $push: { items: { name: \"tablet\", price: 200 } } }\n)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q026", "title": "Update a scalar field using $set", "topic": "CRUD", "subtopic": "updateOne() – $set", "difficulty": "easy", "type": "single", "tags": ["update", "$set", "scalar-field", "exam-core"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Air France has recently passed inspection. In the following document, you need to update the `result` field from `\"Fail\"` to `\"Pass\"`. What should you include in your update document?\n", "context": "You are working with the `inspections` collection and need to update the inspection outcome for a specific business without modifying any other fields.\n", "artifacts": {"sample_docs": [{"_id": "ObjectId('56d61033a378eccde8a837f9')", "id": "31041-2015-ENFO", "certificate_number": 3045325, "business_name": "AIR FRANCE", "date": "Jun 9, 2015", "result": "Fail", "sector": "Travel Agency - 440", "address": {"city": "JAMAICA", "zip": 11430, "street": "JFK INTL AIRPORT BLVD", "number": 1}}], "snippets": [], "notes": ["The `result` field is a scalar string field.", "Only the inspection outcome needs to be changed.", "Other fields must remain unchanged."]}, "choices": [{"key": "A", "text": "{ $set: { result: \"Pass\" } }"}, {"key": "B", "text": "{ $upsert: { result: \"Pass\" } }"}, {"key": "C", "text": "{ $insert: { result: \"Pass\" } }"}, {"key": "D", "text": "{ $push: { result: \"Pass\" } }"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "Use $set to update the value of an existing scalar field.\n", "correct_why": ["`$set` updates only the specified field.", "The existing `result` field is safely changed from `Fail` to `Pass`.", "All other document fields remain untouched."], "wrong_why": {"B": "`upsert` is an option, not an update operator.", "C": "`$insert` is not a valid MongoDB update operator.", "D": "`$push` is used only for array fields, not scalar values."}, "trap": "Confusing update operators with update options or array operators.\n", "mini_demo": "db.inspections.updateOne(\n  { business_name: \"AIR FRANCE\" },\n  { $set: { result: \"Pass\" } }\n)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q027", "title": "findAndModify() return value with new:true", "topic": "CRUD", "subtopic": "findAndModify() behavior", "difficulty": "medium", "type": "single", "tags": ["findAndModify", "update", "return-value", "exam-trap"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Using the `zips` collection, you write the following query. This query updates the population (stored in the `pop` field) for one zip code in Santa Fe, New Mexico. What will be returned? (Select one.)\n", "context": "db.zips.findAndModify({\n  query: { _id: ObjectId(\"5c8eccc1caa187d17ca72ee7\") },\n  update: { $set: { pop: 40000 } },\n  new: true\n})\n", "artifacts": {"sample_docs": [{"_id": "ObjectId('5c8eccc1caa187d17ca72ee7')", "city": "SANTA FE", "state": "NM", "zip": "87501", "pop": 34054}], "snippets": [], "notes": ["findAndModify() returns a document (not a write result).", "By default it returns the pre-update document unless new:true is set."]}, "choices": [{"key": "A", "text": "The updated document, which contains a population of 40000"}, {"key": "B", "text": "The original document, prior to the update, which contains a population of 34054"}, {"key": "C", "text": "All documents with a population of 40000"}, {"key": "D", "text": "A new document that contains only an _id field and a population field"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "findAndModify() returns the updated document when new:true is specified.\n", "correct_why": ["new:true instructs MongoDB to return the document after the update.", "The matched document’s pop field becomes 40000.", "Only the single matched document is returned."], "wrong_why": {"B": "Without new:true, the original (pre-update) document is returned.", "C": "findAndModify() targets and returns a single document, not multiple.", "D": "This operation updates an existing document; it does not create a minimal new one."}, "trap": "Many forget that findAndModify() returns the OLD document by default.\n", "mini_demo": "db.zips.findAndModify({\n  query: { zip: \"87501\" },\n  update: { $set: { pop: 40000 } },\n  new: true\n})\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q029", "title": "Add extra credit to multiple classes using updateMany", "topic": "CRUD", "subtopic": "updateMany with $in and $push", "difficulty": "medium", "type": "single", "tags": ["updateMany", "$in", "$push", "arrays", "exam"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Three computer science classes, with the class_ids of 377, 259, and 350, have earned 100 extra credit points by competing in a hackathon. You need to update the database so that all students who are in these classes receive extra credit points. Which of the following queries will accomplish this goal? (Select one.)\n", "context": "You are using the `grades` collection in the `sample_training` database.\n", "artifacts": {"sample_docs": [{"_id": "ObjectId('5f6a...')", "class_id": 377, "scores": [{"type": "exam", "score": 80}]}], "snippets": [], "notes": ["Multiple documents must be updated.", "Extra credit is stored inside the scores array."]}, "choices": [{"key": "A", "text": "db.grades.insertMany(\n  {\n    class_id: { $in: [377, 259, 350] }\n  },\n  {\n    $push: {\n      scores: { type: \"extra credit\", score: 100 }\n    }\n  }\n)\n"}, {"key": "B", "text": "db.grades.updateMany(\n  {\n    class_id: { $in: [377, 259, 350] }\n  },\n  {\n    $push: {\n      scores: { type: \"extra credit\", score: 100 }\n    }\n  }\n)\n"}, {"key": "C", "text": "db.grades.updateOne(\n  {\n    class_id: { $in: [377, 259, 350] }\n  },\n  {\n    $push: {\n      scores: { type: \"extra credit\", score: 100 }\n    }\n  }\n)\n"}, {"key": "D", "text": "db.grades.findAndModify(\n  {\n    class_id: { $in: [377, 259, 350] }\n  },\n  {\n    $push: {\n      scores: { type: \"extra credit\", score: 100 }\n    }\n  }\n)\n"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "Use updateMany() when multiple documents must be modified.\n", "correct_why": ["updateMany() updates all matching documents.", "$in matches all specified class IDs.", "$push correctly appends a new object to the scores array."], "wrong_why": {"A": "insertMany() inserts new documents instead of updating existing ones.", "C": "updateOne() updates only a single matching document.", "D": "findAndModify() modifies only one document at a time."}, "trap": "Confusing updateOne() or findAndModify() with updateMany() when bulk updates are required.\n", "mini_demo": "db.grades.updateMany(\n  { class_id: { $in: [377, 259, 350] } },\n  { $push: { scores: { type: \"extra credit\", score: 100 } } }\n)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q030", "title": "Delete a specific route using deleteOne()", "topic": "CRUD", "subtopic": "deleteOne()", "difficulty": "medium", "type": "single", "tags": ["deleteOne", "routes", "filters", "exam-trap"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "United Airlines is the only airline that has a route from the Denver Airport (DEN) to the Northwest Arkansas Airport (XNA). It has decided to cancel this route due to low ridership. Which of the following queries will delete the route? (Select one.)\n", "context": "The documents are stored in the `routes` collection of the `sample_training` database.\n", "artifacts": {"sample_docs": [{"_id": "ObjectId('5f6a...')", "airline": {"name": "United Airlines"}, "src_airport": "DEN", "dst_airport": "XNA", "stops": 0}], "snippets": [], "notes": ["deleteOne() removes a single matched document.", "Route identity is determined by src_airport and dst_airport."]}, "choices": [{"key": "A", "text": "db.routes.deleteOne({ \"airline.name\": \"United Airlines\" })"}, {"key": "B", "text": "db.routes.delete({ \"airline.name\": \"United Airlines\" })"}, {"key": "C", "text": "db.routes.delete({ src_airport: \"DEN\", dst_airport: \"XNA\" })"}, {"key": "D", "text": "db.routes.deleteOne({ src_airport: \"DEN\", dst_airport: \"XNA\" })"}], "answer": {"keys": ["D"]}, "rationale": {"rule": "Use deleteOne() with a precise filter to remove a single, specific document.\n", "correct_why": ["Filters exactly match the DEN → XNA route.", "deleteOne() ensures only one document is removed.", "Avoids deleting unrelated United Airlines routes."], "wrong_why": {"A": "Matches airline only, not a specific route.", "B": "`delete()` is not a valid MongoDB method.", "C": "`delete()` is not a valid MongoDB method."}, "trap": "Deleting by airline name instead of route identifiers.\n", "mini_demo": null}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q031", "title": "Delete all routes for a specific airline", "topic": "CRUD", "subtopic": "deleteMany()", "difficulty": "easy", "type": "single", "tags": ["deleteMany", "filters", "nested-fields", "exam"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Air Berlin has filed for bankruptcy and ceased operations. You need to update the routes collection to delete all documents that contain an airline name of Air Berlin. Which of the following queries should you use? (Select one.)\n", "context": "The documents are stored in the `routes` collection.\n", "artifacts": {"sample_docs": [{"_id": "ObjectId('5f6a...')", "airline": {"name": "Air Berlin"}, "src_airport": "TXL", "dst_airport": "LHR"}], "snippets": [], "notes": ["Multiple routes may exist for a single airline.", "Nested fields require dot notation."]}, "choices": [{"key": "A", "text": "db.routes.deleteOne({\n  \"airline.name\": \"Air Berlin\"\n})\n"}, {"key": "B", "text": "db.routes.delete(\"Air Berlin\")\n"}, {"key": "C", "text": "db.routes.deleteMany({\n  \"airline.name\": \"Air Berlin\"\n})\n"}, {"key": "D", "text": "db.routes.deleteMany(\"Air Berlin\")\n"}], "answer": {"keys": ["C"]}, "rationale": {"rule": "Use deleteMany() when removing all documents that match a condition.\n", "correct_why": ["Multiple routes can belong to the same airline.", "deleteMany() removes all matching documents.", "The filter correctly targets the nested airline name."], "wrong_why": {"A": "deleteOne() removes only a single matching document.", "B": "`delete()` is not a valid MongoDB method.", "D": "deleteMany() requires a filter document, not a string."}, "trap": "Using deleteOne() when the question explicitly says delete ALL documents.\n", "mini_demo": "// Deletes every Air Berlin route\ndb.routes.deleteMany(\n  { \"airline.name\": \"Air Berlin\" }\n)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q032", "title": "Sort query results in ascending order", "topic": "CRUD", "subtopic": "find() with sort()", "difficulty": "easy", "type": "single", "tags": ["find", "sort", "ascending", "exam"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Using the inspections collection within the sample_training database, you need to find all inspections that were passed. Your manager has requested that you organize this data by the certificate number in ascending order. Which query should you use? (Select one.)\n", "context": "The documents are stored in the `inspections` collection.\n", "artifacts": {"sample_docs": [{"_id": "ObjectId('5f6a...')", "certificate_number": 3045325, "result": "Pass"}], "snippets": [], "notes": ["Sorting is applied using the sort() method.", "Ascending order is specified using 1."]}, "choices": [{"key": "A", "text": "db.inspections\n  .find({ result: \"Pass\" })\n  .sort({ certificate_number: 1 });\n"}, {"key": "B", "text": "db.inspections\n  .find({ result: \"Pass\" })\n  .sort({ certificate_number: -1 });\n"}, {"key": "C", "text": "db.inspections.find(\n  { result: \"Pass\" },\n  { sort: { certificate_number: 1 } }\n);\n"}, {"key": "D", "text": "db.inspections.find(\n  { result: \"Pass\" },\n  { sort: { certificate_number: -1 } }\n);\n"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "Use the sort() method after find() to order query results.\n", "correct_why": ["Filters only passed inspections.", "sort({ certificate_number: 1 }) sorts in ascending order.", "Uses correct MongoDB method chaining."], "wrong_why": {"B": "Sorts the results in descending order.", "C": "The second argument to find() is for projections, not sorting.", "D": "Incorrect sort placement and descending order."}, "trap": "Attempting to use sort as a projection inside find().\n", "mini_demo": "db.inspections\n  .find({ result: \"Pass\" })\n  .sort({ certificate_number: 1 })\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q033", "title": "Sort and limit results using method chaining", "topic": "CRUD", "subtopic": "find() with sort() and limit()", "difficulty": "easy", "type": "single", "tags": ["find", "sort", "limit", "method-chaining", "exam"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "You are considering creating a new membership tier for your bike sharing service for users who take long trips. Using the trips collection within the sample_training database, you need to find the trips taken by subscribers with the longest trip duration. Return the top 5 results in descending order. Which query should you use? (Select one.)\n", "context": "The documents are stored in the `trips` collection.\n", "artifacts": {"sample_docs": [{"_id": "ObjectId('5f6a...')", "usertype": "Subscriber", "tripduration": 3200}], "snippets": [], "notes": ["Descending order uses -1.", "sort() and limit() must be chained after find()."]}, "choices": [{"key": "A", "text": "db.trips.find(\n  { usertype: \"Subscriber\" },\n  { sort: { tripduration: -1 } },\n  { limit: 5 }\n)\n"}, {"key": "B", "text": "db.trips.find(\n  { usertype: \"Subscriber\" },\n  { sort: { tripduration: 1 } },\n  { limit: 5 }\n)\n"}, {"key": "C", "text": "db.trips\n  .find({ usertype: \"Subscriber\" })\n  .sort({ tripduration: 1 })\n  .limit(5)\n"}, {"key": "D", "text": "db.trips\n  .find({ usertype: \"Subscriber\" })\n  .sort({ tripduration: -1 })\n  .limit(5)\n"}], "answer": {"keys": ["D"]}, "rationale": {"rule": "Use method chaining with sort() and limit() to order and restrict results.\n", "correct_why": ["Filters only Subscriber trips.", "Sorts by tripduration in descending order.", "limit(5) returns only the top five longest trips."], "wrong_why": {"A": "find() does not accept sort and limit as separate arguments.", "B": "Sorts results in ascending order instead of descending.", "C": "Ascending sort returns the shortest trips."}, "trap": "Attempting to pass sort or limit as arguments to find() instead of chaining.\n", "mini_demo": "db.trips\n  .find({ usertype: \"Subscriber\" })\n  .sort({ tripduration: -1 })\n  .limit(5)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q034", "title": "Rules of projection documents", "topic": "CRUD", "subtopic": "find() projection", "difficulty": "easy", "type": "multi", "tags": ["projection", "find", "_id", "exam-fundamentals"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Which of the following statements are true about a projection document? (Select all that apply.)\n", "context": "You are querying documents using the find() method and want to control which fields are returned in the result set.\n", "artifacts": {"sample_docs": [{"_id": 1, "name": "Alice", "age": 30, "email": "alice@example.com"}], "snippets": [], "notes": ["Projection controls which fields are returned by a query.", "`_id` is included by default unless explicitly excluded."]}, "choices": [{"key": "A", "text": "We can include fields in our results by setting their values to 1 in the projection document.\n"}, {"key": "B", "text": "We can exclude fields from our results by setting their values to 0 in the projection document.\n"}, {"key": "C", "text": "We can either include or exclude fields in the results, but not both. The `_id` field is the exception to this rule.\n"}, {"key": "D", "text": "Inclusion and exclusion statements, not including `_id` statements, can be combined with each other in a projection document.\n"}], "answer": {"keys": ["A", "B", "C"]}, "rationale": {"rule": "A projection document may either include fields or exclude fields, but not both at the same time, except for the `_id` field.\n", "correct_why": ["Setting a field to 1 includes it in the result.", "Setting a field to 0 excludes it from the result.", "MongoDB does not allow mixing inclusion and exclusion, except for `_id`."], "wrong_why": {"D": "MongoDB does not allow inclusion and exclusion statements to be mixed in the same projection document. The only exception is the `_id` field.\n"}, "trap": "Many assume that inclusion and exclusion can be mixed freely, which is false. `_id` is the only field that can be excluded alongside inclusion projections.\n", "mini_demo": "// Valid inclusion\ndb.users.find({}, { name: 1, age: 1 })\n\n// Valid exclusion\ndb.users.find({}, { email: 0 })\n\n// Valid: _id excluded with inclusion\ndb.users.find({}, { name: 1, _id: 0 })\n\n// Invalid: mixing inclusion and exclusion\n// db.users.find({}, { name: 1, age: 0 })\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q035", "title": "Exclude _id field in projection", "topic": "CRUD", "subtopic": "find() projection", "difficulty": "easy", "type": "single", "tags": ["projection", "_id", "find", "exam"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "If we don’t want to return the `_id` field, we can add it to the projection document and set it to which of the following values? (Select all that apply.)\n", "context": "MongoDB includes the `_id` field by default in query results unless it is explicitly excluded.\n", "artifacts": {"sample_docs": [{"_id": 1, "name": "Alice", "age": 30}], "snippets": [], "notes": ["`_id` is included by default.", "Projection values must be numeric."]}, "choices": [{"key": "A", "text": "0"}, {"key": "B", "text": "1"}, {"key": "C", "text": "-1"}, {"key": "D", "text": "None of the above"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "The `_id` field can be excluded from query results only by setting its value to 0 in the projection document.\n", "correct_why": ["Setting `_id` to 0 explicitly excludes it from the result.", "`_id` is the only field that can be excluded alongside inclusion projections."], "wrong_why": {"B": "A value of 1 includes the field instead of excluding it.", "C": "-1 is not a valid projection value.", "D": "A valid value (0) exists to exclude the `_id` field."}, "trap": "Assuming that values other than 0 can be used to exclude `_id`.\n", "mini_demo": "// Exclude _id\ndb.users.find({}, { _id: 0 })\n\n// Include _id (default behavior)\ndb.users.find({}, { name: 1 })\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q036", "title": "countDocuments(): what is true?", "topic": "CRUD", "subtopic": "countDocuments()", "difficulty": "easy", "type": "multi", "tags": ["countDocuments", "count", "pymongo", "mongosh"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Which of the following statements are true about the countDocuments() collection method? (Select all that apply.)\n", "context": "You want to count documents in a collection using filters and query operators.\n", "artifacts": {"sample_docs": [{"_id": 1, "status": "active", "age": 25}, {"_id": 2, "status": "inactive", "age": 17}], "snippets": [], "notes": ["countDocuments(filter) returns an exact count.", "An empty filter {} counts all documents."]}, "choices": [{"key": "A", "text": "The method takes a query (filter) parameter, which selects the documents to be counted."}, {"key": "B", "text": "We can use the method to count all documents in a collection."}, {"key": "C", "text": "The method does not support the use of operators in queries that are passed as a parameter."}, {"key": "D", "text": "The method returns the matching documents (a cursor), and you count them by iterating."}], "answer": {"keys": ["A", "B"]}, "rationale": {"rule": "countDocuments(filter) counts matching documents; operators like $gte/$in are supported; {} counts all.\n", "correct_why": ["A is true: the filter decides what gets counted.", "B is true: using {} counts every document in the collection."], "wrong_why": {"C": "False: query operators are supported in countDocuments() filters.", "D": "False: countDocuments() returns a number, not a cursor."}, "trap": "Confusing countDocuments() with find() (cursor) or thinking operators don't work in counts.\n", "mini_demo": "# PyMongo\nfrom pymongo import MongoClient\nclient = MongoClient()\ncol = client.test.users\n\ntotal = col.count_documents({})\nadults = col.count_documents({\"age\": {\"$gte\": 18}})\nprint(total, adults)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-15"}
{"schema_version": "2.0", "id": "CRUD-Q037", "title": "countDocuments() with empty filter", "topic": "CRUD", "subtopic": "countDocuments", "difficulty": "easy", "type": "single", "tags": ["countDocuments", "pymongo", "count"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "What can we expect to be returned by running db.inspections.countDocuments({})? (Select one.)\n", "context": "You are working with the inspections collection inside the sample_training database.\n", "artifacts": {"sample_docs": [{"_id": 1, "result": "Pass"}, {"_id": 2, "result": "Fail"}], "snippets": [], "notes": ["An empty filter {} matches all documents.", "countDocuments() returns a number."]}, "choices": [{"key": "A", "text": "This command does not return anything because it requires a query parameter.\n"}, {"key": "B", "text": "This command returns the total number of documents in the inspections database.\n"}, {"key": "C", "text": "This command returns the total number of documents in the inspections collection.\n"}, {"key": "D", "text": "This command returns a cursor containing all inspection documents.\n"}], "answer": {"keys": ["C"]}, "rationale": {"rule": "countDocuments({}) counts all documents in the collection and returns a number.\n", "correct_why": ["The empty filter {} matches all documents.", "countDocuments() always returns a numeric count.", "The method is executed on the inspections collection."], "wrong_why": {"A": "An empty document {} is a valid query parameter.", "B": "The method counts documents in a collection, not an entire database.", "D": "countDocuments() returns a number, not a cursor."}, "trap": "A common exam trap is confusing database-level scope with collection-level scope.\n", "mini_demo": "# PyMongo example\nfrom pymongo import MongoClient\nclient = MongoClient()\ndb = client.sample_training\n\ntotal = db.inspections.count_documents({})\nprint(total)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-15"}
{"schema_version": "2.0", "id": "CRUD-Q038", "title": "PyMongo: MongoDB documents map to which Python type?", "topic": "CRUD", "subtopic": "PyMongo basics", "difficulty": "easy", "type": "single", "tags": ["pymongo", "python", "bson", "documents"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "What Python data type is used to represent MongoDB documents? (Select one.)\n", "context": "You are using PyMongo and need to know the in-memory representation of a MongoDB document.\n", "artifacts": {"sample_docs": [{"name": "Alice", "age": 30, "skills": ["Python", "MongoDB"]}], "snippets": [], "notes": ["MongoDB document ↔ Python dict", "MongoDB array ↔ Python list"]}, "choices": [{"key": "A", "text": "Document"}, {"key": "B", "text": "Dictionary"}, {"key": "C", "text": "List"}, {"key": "D", "text": "Tuple"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "In PyMongo, BSON documents are represented as Python dictionaries (key–value pairs).\n", "correct_why": ["A MongoDB document is a set of key–value pairs → dict is the natural match.", "PyMongo accepts dict objects directly for inserts/updates."], "wrong_why": {"A": "“Document” is a concept, not a built-in Python type.", "C": "List maps to BSON arrays, not documents.", "D": "Tuple is not used for BSON documents."}, "trap": "Seeing the word “document” and assuming it’s a Python type.\n", "mini_demo": "from pymongo import MongoClient\nclient = MongoClient()\ncol = client.test.users\n\ndoc = {\"name\": \"Alice\", \"age\": 30}\ncol.insert_one(doc)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-15"}
{"schema_version": "2.0", "id": "CRUD-Q039", "title": "PyMongo: Do you need to convert dict → BSON manually?", "topic": "CRUD", "subtopic": "PyMongo inserts", "difficulty": "easy", "type": "single", "tags": ["pymongo", "bson", "insertOne", "serialization"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "You want to insert data stored in a Python dictionary as a new document using PyMongo. What do you need to do to convert a Python dictionary to BSON? (Select one.)\n", "context": "PyMongo handles BSON serialization internally when inserting documents.\n", "artifacts": {"sample_docs": [{"name": "Alice", "age": 30}], "snippets": [], "notes": ["PyMongo serializes dict → BSON automatically.", "`_id` is auto-generated if missing."]}, "choices": [{"key": "A", "text": "Nothing — PyMongo automatically converts a Python dictionary to BSON during insert."}, {"key": "B", "text": "Use an independent library to convert the dictionary to BSON before inserting."}, {"key": "C", "text": "Manually add an `_id` ObjectId so the dictionary can be converted to BSON."}, {"key": "D", "text": "Manually call BSON encoder (e.g., encode()) before insert_one() will accept the document."}], "answer": {"keys": ["A"]}, "rationale": {"rule": "PyMongo automatically serializes Python dicts to BSON for write operations.\n", "correct_why": ["PyMongo performs serialization for you on insert/update.", "You can pass a dict directly into insert_one()."], "wrong_why": {"B": "No extra library is required for normal PyMongo inserts.", "C": "`_id` is optional; MongoDB/PyMongo generates it automatically.", "D": "Manual BSON encoding is not required for insert_one()."}, "trap": "Confusing PyMongo’s internal BSON handling with manual BSON encoding APIs.\n", "mini_demo": "from pymongo import MongoClient\nclient = MongoClient()\ncol = client.test.users\n\ndoc = {\"name\": \"Alice\", \"age\": 30}   # plain dict\nres = col.insert_one(doc)\nprint(res.inserted_id)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-15"}
{"schema_version": "2.0", "id": "CRUD-Q040", "title": "Insert a single document using PyMongo", "topic": "CRUD", "subtopic": "PyMongo insert_one()", "difficulty": "easy", "type": "single", "tags": ["pymongo", "insert_one", "python", "exam"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "You need to insert a new restaurant into the restaurants collection. The new restaurant’s data is stored in a Python dictionary named hyderabadi_biryani. Which of the following expressions will insert the new document into the restaurants collection? (Select one.)\n", "context": "You are using the PyMongo driver to interact with MongoDB.\n", "artifacts": {"sample_docs": [{"name": "Hyderabadi Biryani House", "cuisine": "Indian", "city": "Hyderabad"}], "snippets": [], "notes": ["PyMongo uses insert_one() to insert a single document.", "Python dictionaries are automatically converted to BSON."]}, "choices": [{"key": "A", "text": "result = restaurants.insert_one(hyderabadi_biryani)\n"}, {"key": "B", "text": "result = restaurants.insert(hyderabadi_biryani)\n"}, {"key": "C", "text": "result = restaurants.insert_many(hyderabadi_biryani)\n"}, {"key": "D", "text": "result = restaurants.insert.hyderabadi_biryani\n"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "insert_one() is used to insert a single document represented as a Python dictionary into a MongoDB collection.\n", "correct_why": ["insert_one() accepts a single Python dictionary.", "PyMongo automatically converts the dictionary to BSON.", "Returns an InsertOneResult object."], "wrong_why": {"B": "insert() is not a valid method in PyMongo.", "C": "insert_many() is used for inserting multiple documents.", "D": "This is not valid Python or PyMongo syntax."}, "trap": "Confusing deprecated or non-existent insert methods with insert_one().\n", "mini_demo": "from pymongo import MongoClient\n\nclient = MongoClient()\ndb = client.test\n\nhyderabadi_biryani = {\n  \"name\": \"Hyderabadi Biryani House\",\n  \"cuisine\": \"Indian\"\n}\n\nresult = db.restaurants.insert_one(hyderabadi_biryani)\nprint(result.inserted_id)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "CRUD-Q041", "title": "Insert multiple documents using insert_many", "topic": "CRUD", "subtopic": "insert_many", "difficulty": "easy", "type": "single", "tags": ["insert_many", "pymongo", "bulk_insert"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "The sample_restaurants database is expanding to include restaurants in 5 new neighborhoods. You need to add documents for the 5 new neighborhoods in the neighborhoods collection. Documents for each new neighborhood are stored in the neighborhood_update variable. Which expression should you use to insert these documents into the collection? (Select one.)\n", "context": "neighborhood_update contains five neighborhood documents (a Python list of dicts).\n", "artifacts": {"sample_docs": [{"name": "Downtown", "borough": "Manhattan"}, {"name": "Midtown", "borough": "Manhattan"}, {"name": "Uptown", "borough": "Manhattan"}, {"name": "Old Town", "borough": "Queens"}, {"name": "Riverside", "borough": "Brooklyn"}], "snippets": [], "notes": ["insert_one() → single dict", "insert_many() → list of dicts", "PyMongo has no collection.insert() method"]}, "choices": [{"key": "A", "text": "result = neighborhoods_collection.insert_one(neighborhood_update)\n"}, {"key": "B", "text": "result = neighborhoods_collection.insert_many(neighborhood_update)\n"}, {"key": "C", "text": "result = neighborhoods_collection.insert(neighborhood_update)\n"}, {"key": "D", "text": "result = neighborhoods_collection.insert_one([\n  neighborhood_one,\n  neighborhood_two,\n  neighborhood_three,\n  neighborhood_four,\n  neighborhood_five\n])\n"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "Use insert_many(list_of_documents) when inserting multiple documents at once.\n", "correct_why": ["neighborhood_update is a list of documents.", "insert_many() accepts a list and inserts all documents."], "wrong_why": {"A": "insert_one() expects a single document (dict), not a list of documents.", "C": "insert() is not a valid PyMongo collection method.", "D": "insert_one() cannot insert a list of documents."}, "trap": "Many confuse “one variable” with “one document”. Here the variable holds multiple docs.\n", "mini_demo": "from pymongo import MongoClient\nclient = MongoClient()\ndb = client.sample_restaurants\nneighborhoods_collection = db.neighborhoods\n\nneighborhood_update = [\n  {\"name\": \"Downtown\", \"borough\": \"Manhattan\"},\n  {\"name\": \"Midtown\", \"borough\": \"Manhattan\"},\n  {\"name\": \"Uptown\", \"borough\": \"Manhattan\"},\n  {\"name\": \"Old Town\", \"borough\": \"Queens\"},\n  {\"name\": \"Riverside\", \"borough\": \"Brooklyn\"},\n]\n\nres = neighborhoods_collection.insert_many(neighborhood_update)\nprint(len(res.inserted_ids))\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-15"}
{"schema_version": "2.0", "id": "CRUD-Q042", "title": "Retrieve a single document using find_one", "topic": "CRUD", "subtopic": "find_one", "difficulty": "easy", "type": "single", "tags": ["find_one", "pymongo", "single_document"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "You need to find the population for the 85281 zip code in Tempe, Arizona. You want the results of the specific document returned to you directly within the terminal. Which query should you use to assign the result to the result variable? (Select one.)\n", "context": "# Get reference to the sample_training database\ndb = client.sample_training\n\n# Get reference to zips collection\nzips_collection = db.zips\n\n# Filter document for Tempe zip code\ntempe_zip = { \"zip\": \"85281\" }\n", "artifacts": {"sample_docs": [{"zip": "85281", "city": "TEMPE", "state": "AZ", "pop": 161719}], "snippets": [], "notes": ["find_one() returns a single document (dict).", "find() returns a cursor."]}, "choices": [{"key": "A", "text": "result = sample_training.zips.find({\"zip\": \"85281\"})\n"}, {"key": "B", "text": "result = zips_collection.find(tempe_zip)\n"}, {"key": "C", "text": "result = zips_collection.find_one(tempe_zip)\n"}, {"key": "D", "text": "result = zips.find_one({\"zip\": \"85281\"})\n"}], "answer": {"keys": ["C"]}, "rationale": {"rule": "Use find_one(filter) when you want a single matching document returned directly.\n", "correct_why": ["find_one() returns a document, not a cursor.", "Uses the provided zips_collection reference and the tempe_zip filter."], "wrong_why": {"A": "find() returns a cursor (not the document).", "B": "find() returns a cursor, not a single document.", "D": "zips is not defined in the provided context."}, "trap": "Exam trick: “returned directly” means “document now”, not “cursor later”.\n", "mini_demo": "result = zips_collection.find_one({\"zip\": \"85281\"})\nprint(result[\"pop\"])\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-15"}
{"schema_version": "2.0", "id": "CRUD-Q043", "title": "Find multiple documents using find()", "topic": "CRUD", "subtopic": "find", "difficulty": "easy", "type": "single", "tags": ["find", "pymongo", "cursor", "multiple_documents"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "You need to find all zip codes for the city of Tulsa, Oklahoma. Which query should you use, given the following? (Select one.)\n", "context": "# Get reference to 'sample_training' database\ndb = client.sample_training\n\n# Get a reference to the 'zips' collection\nzips_collection = db.zips\n\n# Query\ntulsa_documents = { \"city\": \"TULSA\" }\n\n# Select an expression that selects the documents matching\n# the query constraint in the 'zips' collection.\ncursor =\n", "artifacts": {"sample_docs": [{"zip": "74103", "city": "TULSA", "state": "OK"}, {"zip": "74104", "city": "TULSA", "state": "OK"}], "snippets": [], "notes": ["find() returns a cursor for multiple matches.", "find_one() returns only one document."]}, "choices": [{"key": "A", "text": "cursor = zips_collection.find(tulsa_documents)\n"}, {"key": "B", "text": "cursor = zips_collection.find_one(tulsa_documents)\n"}, {"key": "C", "text": "cursor = zips_collection.find_one(\"city\": \"TULSA\")\n"}, {"key": "D", "text": "cursor = zips_collection.find(\"city\": \"TULSA\")\n"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "Use find(filter_document) to return all matching documents as a cursor.\n", "correct_why": ["find() returns all matches via a cursor.", "Reuses the provided filter document tulsa_documents."], "wrong_why": {"B": "find_one() returns only one matching document.", "C": "Invalid syntax: filter must be a dict like {'city': 'TULSA'}.", "D": "Invalid usage: find() expects a dict filter, not key-value arguments."}, "trap": "Another common trap: using find_one() when the requirement says “all”.\n", "mini_demo": "cursor = zips_collection.find({\"city\": \"TULSA\"})\nfor doc in cursor:\n    print(doc[\"zip\"])\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-15"}
{"schema_version": "2.0", "id": "CRUD-Q044", "title": "Update a single document using update_one()", "topic": "CRUD", "subtopic": "update", "difficulty": "easy", "type": "single", "tags": ["update_one", "set", "pymongo"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Zvents recently hired 15 new employees, bringing the total number of employees to 70. You need to update the companies collection within the sample_training database, so the number_of_employees field is set to 70. Which query should you use, given the following? (Select one.)\n", "context": "# Get reference to 'sample_training' database\ndb = client.sample_training\n\n# Get reference to 'companies' collection\ncompanies_collection = db.companies\n\n# Filter\ndocument_to_update = { \"name\": \"Zvents\" }\n\n# Update\nupdate_employees = { \"$set\": { \"number_of_employees\": 70 } }\n\n# Select an expression that updates the number of employees.\n", "artifacts": {"sample_docs": [{"name": "Zvents", "number_of_employees": 55}], "snippets": [], "notes": ["update_one(filter, update) updates the first matching document.", "Use $set to modify specific fields without replacing the entire document."]}, "choices": [{"key": "A", "text": "result = db.companies.update_one({document_to_update, update_employees})\n"}, {"key": "B", "text": "result = companies_collection.update_one({ document_to_update }, { update_employees })\n"}, {"key": "C", "text": "result = companies_collection.update(document_to_update, update_employees)\n"}, {"key": "D", "text": "result = companies_collection.update_one(document_to_update, update_employees)\n"}], "answer": {"keys": ["D"]}, "rationale": {"rule": "In PyMongo, update_one(filter, update) is the correct method to update a single document using an update operator like $set.\n", "correct_why": ["update_one() is the correct PyMongo method for updating one matching document.", "The filter (document_to_update) and update (update_employees) are passed as two separate arguments.", "$set updates only the specified field, preserving other fields."], "wrong_why": {"A": "update_one() requires two separate arguments (filter, update); this combines them incorrectly.", "B": "The filter and update are incorrectly wrapped inside extra braces, changing the argument types.", "C": "update() is deprecated in PyMongo; use update_one() or update_many() instead."}, "trap": "A common exam trap is adding extra braces around variables or using the deprecated update() method.\n", "mini_demo": "from pymongo import MongoClient\n\nclient = MongoClient()\ndb = client.sample_training\ncompanies_collection = db.companies\n\nresult = companies_collection.update_one(\n    { \"name\": \"Zvents\" },\n    { \"$set\": { \"number_of_employees\": 70 } }\n)\n\nprint(result.matched_count, result.modified_count)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-15"}
{"schema_version": "2.0", "id": "CRUD-Q045", "title": "Update many documents using update_many with $in", "topic": "CRUD", "subtopic": "update_many", "difficulty": "easy", "type": "single", "tags": ["update_many", "pymongo", "$in", "$set"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "The companies collection is missing data on the initial public offerings (IPO) for Linkedin and Facebook. Given the Python file below, select the expression that sets the ipo field to True for the two companies. (Select one.)\n", "context": "# Get reference to 'sample_training' database\ndb = client.sample_training\n\n# Get reference to 'companies' collection\ncompanies_collection = db.companies\n\n# Filter\nselect_companies = { \"name\": { \"$in\": [\"Facebook\", \"LinkedIn\"] } }\n\n# Update\nset_ipo = { \"$set\": { \"ipo\": True } }\n", "artifacts": {"sample_docs": [{"name": "Facebook", "ipo": false}, {"name": "LinkedIn", "ipo": false}], "snippets": [], "notes": ["update_many(filter, update) updates all matching documents.", "db is a database handle; update_many is called on the collection handle."]}, "choices": [{"key": "A", "text": "result = sample_training.update_many(select_companies, set_ipo)\n"}, {"key": "B", "text": "result = companies_collection.update_many(select_companies, set_ipo)\n"}, {"key": "C", "text": "result = companies.update(select_companies, set_ipo)\n"}, {"key": "D", "text": "result = companies_collection.update_many[select_companies, set_ipo]\n"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "To update multiple documents in PyMongo, call update_many() on the collection object with (filter, update).\n", "correct_why": ["companies_collection is the collection handle.", "update_many(filter, update) correctly applies $set to both matched companies."], "wrong_why": {"A": "update_many is not a database-level method; it must be called on a collection.", "C": "companies is not defined in the given context (and update() is not the intended method here).", "D": "Invalid syntax: [] indexing is not how you call methods."}, "trap": "Confusing db vs collection handles, and mixing method-call parentheses with bracket syntax.\n", "mini_demo": "res = companies_collection.update_many(\n  {\"name\": {\"$in\": [\"Facebook\", \"LinkedIn\"]}},\n  {\"$set\": {\"ipo\": True}}\n)\nprint(res.matched_count, res.modified_count)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-15"}
{"schema_version": "2.0", "id": "CRUD-Q046", "title": "Delete multiple documents using delete_many", "topic": "CRUD", "subtopic": "delete_many", "difficulty": "easy", "type": "single", "tags": ["delete_many", "pymongo", "bulk_delete"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Use the dataset below to answer the question that follows. When you run the given command, what is the result? (Select one.)\n", "context": "# Dataset in the accounts collection\n\n{\n  \"account_id\": \"MDB156014571\",\n  \"account_holder\": \"Adelen Værnes\",\n  \"account_type\": \"savings\",\n  \"balance\": 1519.62,\n  \"transfers_complete\": [\n    \"TR670287839\",\n    \"TR679752211\",\n    \"TR854525844\",\n    \"TR762109284\"\n  ]\n}\n\n{\n  \"account_id\": \"MDB190468049\",\n  \"account_holder\": \"Louis Lewis\",\n  \"account_type\": \"savings\",\n  \"balance\": 4155.67,\n  \"transfers_complete\": [\n    \"TR859060098\",\n    \"TR729044189\",\n    \"TR126484922\",\n    \"TR617907396\",\n    \"TR598541455\"\n  ]\n}\n\n{\n  \"account_id\": \"MDB870205338\",\n  \"account_holder\": \"Juan Perez\",\n  \"account_type\": \"checking\",\n  \"balance\": 1907.8,\n  \"transfers_complete\": [\n    \"TR432759196\",\n    \"TR797654953\",\n    \"TR391563093\",\n    \"TR464853424\",\n    \"TR922604241\"\n  ]\n}\n\n# Command executed\nfilter = { \"account_type\": \"checking\" }\nresult = db.accounts.delete_many(filter)\n", "artifacts": {"sample_docs": [{"account_id": "MDB156014571", "account_holder": "Adelen Værnes", "account_type": "savings"}, {"account_id": "MDB190468049", "account_holder": "Louis Lewis", "account_type": "savings"}, {"account_id": "MDB870205338", "account_holder": "Juan Perez", "account_type": "checking"}], "snippets": [], "notes": ["delete_many() removes entire documents, not individual fields.", "The filter matches documents where account_type is 'checking'."]}, "choices": [{"key": "A", "text": "Louis Lewis and Adelen Værnes are the only two documents left in the collection."}, {"key": "B", "text": "Juan Perez is the only document left in the collection."}, {"key": "C", "text": "No changes happen to the collection."}, {"key": "D", "text": "The account_type field is removed from all documents."}], "answer": {"keys": ["A"]}, "rationale": {"rule": "delete_many() deletes all documents that match the given filter.\n", "correct_why": ["Only Juan Perez has account_type set to 'checking'.", "That document matches the filter and is deleted.", "The two savings accounts remain in the collection."], "wrong_why": {"B": "Juan Perez is deleted, so he cannot be the only document remaining.", "C": "A matching document exists, so the collection is modified.", "D": "Field removal requires $unset, not delete_many()."}, "trap": "A common exam trap is confusing document deletion (delete_many) with field deletion using $unset.\n", "mini_demo": "from pymongo import MongoClient\n\nclient = MongoClient(\"mongodb://localhost:27017\")\ndb = client.sample_training\naccounts = db.accounts\n\nfilter_query = {\"account_type\": \"checking\"}\nresult = accounts.delete_many(filter_query)\n\nprint(\"Documents deleted:\", result.deleted_count)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-15"}
{"schema_version": "2.0", "id": "CRUD-Q047", "title": "Delete a single document using delete_one", "topic": "CRUD", "subtopic": "delete_one", "difficulty": "easy", "type": "single", "tags": ["delete_one", "pymongo", "delete"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "A bank has identified a fraudulent account with the account_id MDB905411541. Given the Python file below, which expression should you use to remove this account? (Select one.)\n", "context": "# Get reference to 'bank' database\ndb = client.bank\n\n# Get a reference to the 'accounts' collection\naccounts_collection = db.accounts\n\n# Filter by account_id\nfraud_account = { \"account_id\": \"MDB905411541\" }\n\n# Select an expression that deletes the target account.\n", "artifacts": {"sample_docs": [{"account_id": "MDB905411541", "account_holder": "Fraudulent User", "account_type": "checking", "balance": 0.0}], "snippets": [], "notes": ["Use delete_one() when exactly one document must be removed.", "delete() and hide() are not valid PyMongo collection methods."]}, "choices": [{"key": "A", "text": "result = accounts_collection.delete(fraud_account)\n"}, {"key": "B", "text": "result = accounts_collection.hide(fraud_account)\n"}, {"key": "C", "text": "result = accounts_collection.delete(account)\n"}, {"key": "D", "text": "result = accounts_collection.delete_one(fraud_account)\n"}], "answer": {"keys": ["D"]}, "rationale": {"rule": "The delete_one() method removes exactly one document that matches the given filter document.\n", "correct_why": ["delete_one() is the correct PyMongo method for deleting a single document.", "The filter fraud_account correctly matches the target account_id.", "The operation removes only the fraudulent account."], "wrong_why": {"A": "delete() is not a valid method in PyMongo.", "B": "hide() is not a MongoDB or PyMongo operation.", "C": "The variable 'account' is not defined in the given context."}, "trap": "A common exam trap is using non-existent methods like delete() instead of the valid delete_one() or delete_many() APIs.\n", "mini_demo": "from pymongo import MongoClient\n\nclient = MongoClient(\"mongodb://localhost:27017\")\ndb = client.bank\naccounts = db.accounts\n\nfraud_account = {\"account_id\": \"MDB905411541\"}\nresult = accounts.delete_one(fraud_account)\n\nprint(\"Deleted documents:\", result.deleted_count)\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-15"}
{"schema_version": "2.0", "id": "DOCMODEL-Q001", "title": "Different document shapes in the same collection", "topic": "MongoDB Overview", "subtopic": "Document model & schema flexibility", "difficulty": "easy", "type": "single", "tags": ["document-model", "schema-flexibility", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Can MongoDB store documents of totally different shapes within the same collection?\n", "context": "You are evaluating MongoDB’s schema flexibility compared to traditional relational databases.\n", "artifacts": {"sample_docs": [{"_id": 1, "name": "Alice", "age": 30}, {"_id": 2, "product": "Laptop", "price": 75000, "in_stock": true}], "snippets": [], "notes": ["MongoDB uses a flexible schema model.", "Documents in the same collection do not need to share the same fields."]}, "choices": [{"key": "A", "text": "Yes"}, {"key": "B", "text": "No"}, {"key": "C", "text": "Only if all fields are optional"}, {"key": "D", "text": "Only when using MongoDB Atlas"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "MongoDB collections can contain documents with different structures.\n", "correct_why": ["MongoDB is schema-flexible and does not enforce a fixed structure.", "Each document can have different fields and data types.", "This is a core feature of the MongoDB document model."], "wrong_why": {"B": "MongoDB does not require all documents to have the same shape.", "C": "Field optionality is not required for schema flexibility.", "D": "This behavior is inherent to MongoDB, not specific to Atlas."}, "trap": "Assuming MongoDB enforces a rigid schema like relational databases.\n", "mini_demo": "db.test.insertMany([\n  { name: \"Alice\", age: 30 },\n  { product: \"Phone\", price: 30000 }\n])\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "DOCMODEL-Q002", "title": "Benefit of schema flexibility", "topic": "MongoDB Overview", "subtopic": "Schema flexibility", "difficulty": "easy", "type": "single", "tags": ["schema-flexibility", "polymorphic-data", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "What is the main benefit of MongoDB’s schema flexibility?\n", "context": "You are comparing MongoDB’s document model with traditional relational databases during application design.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["Schema flexibility allows documents with different shapes.", "This reduces friction during iterative development."]}, "choices": [{"key": "A", "text": "Requires schema migrations for every change"}, {"key": "B", "text": "Supports polymorphic data and quicker development"}, {"key": "C", "text": "Enforces strict data types"}, {"key": "D", "text": "Requires all documents to follow the same structure"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "Schema flexibility enables polymorphic documents and faster iteration.\n", "correct_why": ["Different document shapes can coexist in the same collection.", "Developers can evolve the data model without costly migrations.", "This speeds up development and supports agile workflows."], "wrong_why": {"A": "MongoDB does not require schema migrations for every change.", "C": "MongoDB does not enforce strict schemas by default.", "D": "Collections do not require uniform document structures."}, "trap": "Confusing MongoDB’s flexible schema with rigid relational schemas.\n", "mini_demo": "db.items.insertMany([\n  { type: \"book\", title: \"MongoDB Basics\", pages: 200 },\n  { type: \"video\", title: \"MongoDB Intro\", duration_min: 45 }\n])\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "DOCMODEL-Q003", "title": "Enforcing document structure in MongoDB", "topic": "MongoDB Overview", "subtopic": "Schema validation", "difficulty": "easy", "type": "single", "tags": ["schema-validation", "json-schema", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "How can MongoDB enforce uniform document structure if needed?\n", "context": "While MongoDB is schema-flexible by default, some applications require stricter control over document structure and field types.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["MongoDB supports optional schema enforcement.", "Schema validation is applied at the collection level."]}, "choices": [{"key": "A", "text": "By installing plugins"}, {"key": "B", "text": "By using JSON Schema Validation"}, {"key": "C", "text": "By default, all collections are uniform"}, {"key": "D", "text": "By converting collections into relational tables"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "MongoDB enforces structure using JSON Schema validation when required.\n", "correct_why": ["MongoDB supports JSON Schema–based validation at the collection level.", "This allows enforcing required fields, data types, and value constraints.", "Validation rules are checked on insert and update operations."], "wrong_why": {"A": "No plugins are required to enforce schema rules in MongoDB.", "C": "Collections are schema-flexible by default, not uniform.", "D": "MongoDB does not convert collections into relational tables."}, "trap": "Assuming MongoDB cannot enforce schemas because it is schema-flexible.\n", "mini_demo": "db.createCollection(\"users\", {\n  validator: {\n    $jsonSchema: {\n      bsonType: \"object\",\n      required: [\"name\", \"email\"],\n      properties: {\n        name: { bsonType: \"string\" },\n        email: { bsonType: \"string\" }\n      }\n    }\n  }\n})\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "DOCMODEL-Q004", "title": "Impact of missing required fields", "topic": "MongoDB Overview", "subtopic": "Schema design & data quality", "difficulty": "easy", "type": "single", "tags": ["schema-design", "data-quality", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Why should you avoid inserting documents with missing required fields?\n", "context": "You are designing an application that relies on consistent data for querying, reporting, and analytics.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["MongoDB allows missing fields unless schema validation is enforced.", "Application logic often assumes certain fields exist."]}, "choices": [{"key": "A", "text": "MongoDB rejects the insert"}, {"key": "B", "text": "Your queries or reports might fail or give inaccurate results"}, {"key": "C", "text": "The document becomes automatically deleted"}, {"key": "D", "text": "Indexes stop working on the collection"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "Missing fields can break assumptions made by queries and applications.\n", "correct_why": ["Queries may return incomplete or misleading results.", "Aggregations and reports may fail or produce incorrect metrics.", "Application code often expects certain fields to exist."], "wrong_why": {"A": "MongoDB accepts documents with missing fields unless validation is enabled.", "C": "MongoDB never auto-deletes documents due to missing fields.", "D": "Indexes continue to work, but results may be incomplete."}, "trap": "Assuming MongoDB automatically enforces required fields by default.\n", "mini_demo": "// Query expecting 'price' may miss documents without it\ndb.products.find({ price: { $gt: 1000 } })\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "DRIVER-Q001", "title": "Duplicate key exception in PyMongo", "topic": "Drivers", "subtopic": "PyMongo error handling", "difficulty": "easy", "type": "single", "tags": ["pymongo", "exceptions", "duplicate-key", "exam-favorite"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Which of the following exceptions is raised in PyMongo when you attempt to insert a document that violates a unique index (duplicate key)?\n", "context": "You are inserting documents into a MongoDB collection using PyMongo where a unique index is defined on a field.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["PyMongo raises specific exceptions for different write failures.", "Duplicate key errors are common when enforcing uniqueness."]}, "choices": [{"key": "A", "text": "WriteError"}, {"key": "B", "text": "DuplicateKeyError"}, {"key": "C", "text": "OperationFailure"}, {"key": "D", "text": "BulkWriteError"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "Duplicate key violations in PyMongo raise DuplicateKeyError.\n", "correct_why": ["DuplicateKeyError is raised when a unique index constraint is violated.", "It is a subclass of WriteError in PyMongo.", "This exception is explicitly documented and commonly tested."], "wrong_why": {"A": "WriteError is a base class, but PyMongo raises DuplicateKeyError specifically.", "C": "OperationFailure is used for command-level failures, not duplicate inserts.", "D": "BulkWriteError occurs during bulk write operations, not single inserts."}, "trap": "Choosing WriteError because it sounds generic, instead of the specific exception.\n", "mini_demo": "from pymongo import MongoClient\nfrom pymongo.errors import DuplicateKeyError\n\ntry:\n    db.users.insert_one({ \"_id\": 1, \"name\": \"Alice\" })\n    db.users.insert_one({ \"_id\": 1, \"name\": \"Bob\" })\nexcept DuplicateKeyError:\n    print(\"Duplicate key detected\")\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "DRIVER-Q002", "title": "Handling connection timeout in PyMongo", "topic": "Drivers", "subtopic": "PyMongo connection handling", "difficulty": "easy", "type": "single", "tags": ["pymongo", "connection-timeout", "error-handling", "exam-core"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "How should you handle a connection timeout in PyMongo?\n", "context": "Your Python application is communicating with MongoDB using PyMongo and encounters a connection timeout due to network instability or temporary server unavailability.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["Connection timeouts are typically transient failures.", "Robust applications handle such failures gracefully."]}, "choices": [{"key": "A", "text": "Retry the operation"}, {"key": "B", "text": "Ignore the error"}, {"key": "C", "text": "Use a larger batch size"}, {"key": "D", "text": "Disable connection pooling"}], "answer": {"keys": ["A"]}, "rationale": {"rule": "Transient connection issues should be handled by retrying the operation.\n", "correct_why": ["Connection timeouts are often temporary network issues.", "Retrying allows the operation to succeed once connectivity is restored.", "PyMongo is designed to work with retryable reads and writes."], "wrong_why": {"B": "Ignoring the error can lead to data loss or inconsistent application behavior.", "C": "Batch size has no effect on connection timeouts.", "D": "Disabling connection pooling reduces performance and does not solve timeouts."}, "trap": "Assuming connection timeouts are harmless and can be ignored.\n", "mini_demo": "from pymongo import MongoClient, errors\n\ntry:\n    db.collection.find_one()\nexcept errors.ConnectionFailure:\n    # retry logic here\n    print(\"Retrying operation...\")\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "ERROR-Q001", "title": "Ordering specific exceptions before general ones", "topic": "Drivers", "subtopic": "Error handling best practices", "difficulty": "easy", "type": "single", "tags": ["exceptions", "error-handling", "best-practices", "exam-core"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "Why should you handle specific exceptions before general ones in error handling?\n", "context": "You are writing robust application code (for example, using PyMongo) and want to respond appropriately to different failure scenarios.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["Exception handling follows a top-down matching order.", "More specific exceptions carry more contextual information."]}, "choices": [{"key": "A", "text": "For performance"}, {"key": "B", "text": "For more precise and custom remediation"}, {"key": "C", "text": "For code brevity"}, {"key": "D", "text": "Because general exceptions are deprecated"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "Catch specific exceptions first to handle known failure cases accurately.\n", "correct_why": ["Specific exceptions allow tailored recovery actions.", "They provide clearer context about what went wrong.", "Catching general exceptions first would mask specific error conditions."], "wrong_why": {"A": "Exception ordering is about correctness, not performance.", "C": "Code brevity is not the goal of proper error handling.", "D": "General exceptions are not deprecated."}, "trap": "Catching a broad exception first, which prevents specific handlers from ever executing.\n", "mini_demo": "from pymongo.errors import DuplicateKeyError, PyMongoError\n\ntry:\n    db.users.insert_one({ \"_id\": 1 })\n    db.users.insert_one({ \"_id\": 1 })\nexcept DuplicateKeyError:\n    print(\"Handle duplicate key specifically\")\nexcept PyMongoError:\n    print(\"Handle other MongoDB-related errors\")\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "ERROR-Q002", "title": "MongoDB error code 121", "topic": "MongoDB Overview", "subtopic": "Error codes & validation", "difficulty": "easy", "type": "single", "tags": ["error-codes", "schema-validation", "exam-core"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "What does MongoDB error code 121 indicate?\n", "context": "You are inserting or updating a document in a collection that has schema validation rules enabled.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["MongoDB assigns specific numeric codes to common error conditions.", "Error code 121 is strongly associated with schema validation."]}, "choices": [{"key": "A", "text": "Duplicate key"}, {"key": "B", "text": "Validation failure"}, {"key": "C", "text": "No such collection"}, {"key": "D", "text": "Connection timeout"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "Error code 121 means the document failed schema validation.\n", "correct_why": ["Error code 121 corresponds to `DocumentValidationFailure`.", "It occurs when a document violates JSON Schema validation rules.", "This commonly happens on insert or update operations."], "wrong_why": {"A": "Duplicate key errors use code 11000.", "C": "Missing collections raise different command or namespace errors.", "D": "Connection timeouts are network-level errors, not validation errors."}, "trap": "Confusing validation errors (121) with duplicate key errors (11000).\n", "mini_demo": "db.createCollection(\"users\", {\n  validator: {\n    $jsonSchema: {\n      bsonType: \"object\",\n      required: [\"email\"],\n      properties: {\n        email: { bsonType: \"string\" }\n      }\n    }\n  }\n})\n\n// This insert triggers error code 121\ndb.users.insertOne({ name: \"Alice\" })\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "OVERVIEW-Q001", "title": "MongoDB vs MongoDB Atlas relationship", "topic": "MongoDB Overview", "subtopic": "MongoDB vs Atlas", "difficulty": "easy", "type": "single", "tags": ["atlas", "architecture", "basics"], "exam_relevance": {"pool": "learning", "confidence": "high"}, "prompt": "What is the relationship between the MongoDB database and MongoDB Atlas?\n", "context": "MongoDB provides both a core database product and a managed cloud platform. Understanding how these two relate is essential for deployment and architecture decisions.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["MongoDB Atlas is a fully managed Database-as-a-Service (DBaaS).", "The MongoDB database (server) is the core engine used by Atlas and self-managed deployments.", "Atlas runs MongoDB for you on AWS, Azure, or GCP."]}, "choices": [{"key": "A", "text": "The MongoDB database is the locally deployed version of MongoDB Atlas."}, {"key": "B", "text": "The MongoDB database is a core element of MongoDB Atlas, which is a multi-cloud developer data platform."}, {"key": "C", "text": "The MongoDB database is the free version of MongoDB Atlas."}, {"key": "D", "text": "MongoDB Atlas is a lightweight client tool used to manage local MongoDB databases."}], "answer": {"keys": ["B"]}, "rationale": {"rule": "Atlas = managed platform built on top of the MongoDB database engine.\n", "correct_why": ["MongoDB is the core database engine that stores and queries data.", "MongoDB Atlas is a managed service that runs MongoDB for you on cloud providers.", "Atlas adds features like backups, scaling, monitoring, and security on top of MongoDB."], "wrong_why": {"A": "Atlas is not something that runs locally; it is a cloud-managed service.", "C": "MongoDB itself is not a 'free version' of Atlas; both free and paid tiers exist in Atlas.", "D": "Atlas is not a client tool; it is a full database platform."}, "trap": "Confusing MongoDB (the database engine) with MongoDB Atlas (the managed cloud service).\n", "mini_demo": "# MongoDB can run locally:\nmongod --dbpath /data/db\n\n# MongoDB Atlas runs the same MongoDB engine,\n# but MongoDB Inc manages the infrastructure for you.\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
{"schema_version": "2.0", "id": "SHELL-Q001", "title": "Error handling in mongosh", "topic": "Tools & Tooling", "subtopic": "mongosh error handling", "difficulty": "easy", "type": "single", "tags": ["mongosh", "error-handling", "javascript", "exam-core"], "exam_relevance": {"pool": "exam", "confidence": "high"}, "prompt": "In mongosh, which feature is used to catch errors?\n", "context": "The MongoDB Shell (mongosh) is based on JavaScript and follows JavaScript error-handling semantics.\n", "artifacts": {"sample_docs": [], "snippets": [], "notes": ["mongosh uses JavaScript syntax.", "Error handling follows standard JavaScript patterns."]}, "choices": [{"key": "A", "text": "try…except"}, {"key": "B", "text": "try…catch"}, {"key": "C", "text": "onError"}, {"key": "D", "text": "errorHandler"}], "answer": {"keys": ["B"]}, "rationale": {"rule": "mongosh follows JavaScript syntax, which uses try…catch for error handling.\n", "correct_why": ["mongosh is built on JavaScript, not Python.", "JavaScript uses try…catch blocks to handle exceptions.", "This is the correct and supported way to catch errors in mongosh."], "wrong_why": {"A": "try…except is Python syntax, not JavaScript.", "C": "onError is not a valid mongosh or JavaScript construct.", "D": "errorHandler is not a built-in error-handling feature in mongosh."}, "trap": "Confusing Python (`try…except`) with JavaScript (`try…catch`) syntax.\n", "mini_demo": "try {\n  db.users.insertOne({ _id: 1 })\n  db.users.insertOne({ _id: 1 })\n} catch (e) {\n  print(\"Error occurred:\", e.message)\n}\n"}, "status": "published", "author": "prashanth", "updated_at": "2025-12-13"}
